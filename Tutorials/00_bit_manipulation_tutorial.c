/**
 ******************************************************************************
 * @file           : 00_bit_manipulation_tutorial.c
 * @brief          : Bit Manipulation Fundamentals - START HERE!
 ******************************************************************************
 * 
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
 *  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• 
 *  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•  
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 *  â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•       â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   
 * 
 *  â­ START HERE! â­
 *  
 *  This tutorial teaches the bit manipulation skills you NEED before
 *  learning any STM32 peripheral. Every register configuration uses
 *  these techniques!
 * 
 *  WHAT YOU'LL LEARN:
 *  1. Binary and hexadecimal basics
 *  2. Bitwise operators: AND, OR, XOR, NOT, SHIFT
 *  3. Setting, clearing, and toggling bits
 *  4. Reading specific bits
 *  5. Bit fields and masks
 *  6. The (pin Ã— bits_per_pin) formula
 *  7. Common patterns used in ALL tutorials
 * 
 *  DIFFICULTY: â­ (Beginner - REQUIRED FOUNDATION!)
 * 
 ******************************************************************************
 */

#include <stdint.h>

/* ============================================================================
 * 
 *  LESSON 0: BINARY AND HEXADECIMAL BASICS
 *  =========================================
 * 
 *  In microcontrollers, we work with BITS (0 or 1).
 *  A 32-bit register has 32 individual bits we can control.
 *  
 *  BINARY: Base 2 (each digit is 0 or 1)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *      Bit Position:   7   6   5   4   3   2   1   0
 *                    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
 *      Binary:       â”‚ 1 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 1 â”‚ 0 â”‚ = 0b10100110
 *                    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
 *      Weight:       128  64  32  16   8   4   2   1
 *                      â†“   â†“   â†“           â†“   â†“
 *      Value:        128 + 32 +           4 + 2     = 166 (decimal)
 *  
 *  
 *  HEXADECIMAL: Base 16 (compact way to write binary)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *      Hex Digits: 0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F
 *      Decimal:    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
 *      Binary:     0000 0001 0010 0011 ... 1010 1011 1100 1101 1110 1111
 *  
 *      Each hex digit = 4 bits (1 nibble)
 *  
 *      Example:
 *      Binary:  1010 0110
 *      Hex:      A    6   = 0xA6
 *  
 *  
 *  WHY HEXADECIMAL?
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *      32-bit binary: 0b11111111000000001111111100000000  (hard to read!)
 *      32-bit hex:    0xFF00FF00  (easy to read!)
 *  
 *      Each hex digit maps exactly to 4 bits - perfect for registers!
 * 
 * ============================================================================ */

/* ============================================================================
 * 
 *  LESSON 1: THE BITWISE OPERATORS
 *  ================================
 * 
 *  There are 6 bitwise operators in C. Let's learn each one!
 * 
 * ============================================================================ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 1: AND (&)
 *  
 *  Both bits must be 1 to get 1.
 *  
 *  Truth Table:
 *  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
 *  â”‚ A â”‚ B â”‚ A & B â”‚
 *  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ 0 â”‚ 0 â”‚   0   â”‚
 *  â”‚ 0 â”‚ 1 â”‚   0   â”‚
 *  â”‚ 1 â”‚ 0 â”‚   0   â”‚
 *  â”‚ 1 â”‚ 1 â”‚   1   â”‚
 *  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  USE: Clearing bits, checking if a bit is set, masking
 *  
 *  Example:
 *      0b1010 & 0b1100 = 0b1000
 *            â†“
 *      1 0 1 0
 *    & 1 1 0 0
 *    â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      1 0 0 0
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 2: OR (|)
 *  
 *  Either bit being 1 gives 1.
 *  
 *  Truth Table:
 *  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
 *  â”‚ A â”‚ B â”‚ A | B â”‚
 *  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ 0 â”‚ 0 â”‚   0   â”‚
 *  â”‚ 0 â”‚ 1 â”‚   1   â”‚
 *  â”‚ 1 â”‚ 0 â”‚   1   â”‚
 *  â”‚ 1 â”‚ 1 â”‚   1   â”‚
 *  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  USE: Setting bits
 *  
 *  Example:
 *      0b1010 | 0b1100 = 0b1110
 *            â†“
 *      1 0 1 0
 *    | 1 1 0 0
 *    â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      1 1 1 0
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 3: XOR (^)
 *  
 *  Bits must be DIFFERENT to get 1.
 *  
 *  Truth Table:
 *  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
 *  â”‚ A â”‚ B â”‚ A ^ B â”‚
 *  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ 0 â”‚ 0 â”‚   0   â”‚
 *  â”‚ 0 â”‚ 1 â”‚   1   â”‚
 *  â”‚ 1 â”‚ 0 â”‚   1   â”‚
 *  â”‚ 1 â”‚ 1 â”‚   0   â”‚
 *  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  USE: Toggling bits (flip 0â†’1 or 1â†’0)
 *  
 *  Example:
 *      0b1010 ^ 0b1100 = 0b0110
 *            â†“
 *      1 0 1 0
 *    ^ 1 1 0 0
 *    â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      0 1 1 0
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 4: NOT (~)
 *  
 *  Flips all bits. (Also called "complement" or "invert")
 *  
 *  Truth Table:
 *  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
 *  â”‚ A â”‚  ~A  â”‚
 *  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ 0 â”‚   1  â”‚
 *  â”‚ 1 â”‚   0  â”‚
 *  â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  USE: Creating inverted masks for clearing bits
 *  
 *  Example (8-bit):
 *      ~0b00001111 = 0b11110000
 *      ~0x0F = 0xF0
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 5: LEFT SHIFT (<<)
 *  
 *  Moves bits to the LEFT, fills with 0s on the right.
 *  Each shift left = multiply by 2.
 *  
 *  Example:
 *      0b00000001 << 3 = 0b00001000
 *      
 *      1 << 0 = 0b00000001 = 1
 *      1 << 1 = 0b00000010 = 2
 *      1 << 2 = 0b00000100 = 4
 *      1 << 3 = 0b00001000 = 8
 *      1 << 7 = 0b10000000 = 128
 *  
 *  USE: Creating bit masks, positioning bits
 *  
 *  â­ MOST IMPORTANT PATTERN: (1 << n) creates a mask with bit n set!
 *  
 *      (1 << 0) = bit 0 = 0x01 = 0b00000001
 *      (1 << 5) = bit 5 = 0x20 = 0b00100000
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATOR 6: RIGHT SHIFT (>>)
 *  
 *  Moves bits to the RIGHT.
 *  Each shift right = divide by 2.
 *  
 *  Example:
 *      0b11110000 >> 4 = 0b00001111
 *      0xF0 >> 4 = 0x0F
 *  
 *  USE: Reading bit fields, extracting values
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  LESSON 2: THE FOUR ESSENTIAL OPERATIONS
 *  =========================================
 * 
 *  These are the building blocks for ALL peripheral programming!
 * 
 * ============================================================================ */

/* Example register - we'll manipulate this */
volatile uint32_t example_register = 0;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATION 1: SET A BIT (make it 1)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  Pattern: register |= (1 << bit_number);
 *  
 *  How it works:
 *  
 *      Register:       0 1 0 0 0 0 0 0
 *      Mask (1<<5):    0 0 1 0 0 0 0 0
 *                    | â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      Result:         0 1 1 0 0 0 0 0
 *                          â†‘
 *                    Bit 5 is now SET!
 *  
 *  The OR (|) preserves existing bits and sets the target bit.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

void example_set_bit(void) {
    /* Set bit 5 */
    example_register |= (1 << 5);
    
    /* Set bit 0 */
    example_register |= (1 << 0);
    
    /* Set multiple bits at once (bits 3 and 7) */
    example_register |= (1 << 3) | (1 << 7);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATION 2: CLEAR A BIT (make it 0)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  Pattern: register &= ~(1 << bit_number);
 *  
 *  How it works:
 *  
 *      Register:       0 1 1 0 1 0 0 0
 *      Mask (1<<5):    0 0 1 0 0 0 0 0
 *      ~Mask:          1 1 0 1 1 1 1 1   â† NOT inverts the mask
 *                    & â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      Result:         0 1 0 0 1 0 0 0
 *                          â†‘
 *                    Bit 5 is now CLEARED!
 *  
 *  The AND (&) with inverted mask clears only the target bit.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

void example_clear_bit(void) {
    /* Clear bit 5 */
    example_register &= ~(1 << 5);
    
    /* Clear bit 0 */
    example_register &= ~(1 << 0);
    
    /* Clear multiple bits at once (bits 3 and 7) */
    example_register &= ~((1 << 3) | (1 << 7));
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATION 3: TOGGLE A BIT (flip it)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  Pattern: register ^= (1 << bit_number);
 *  
 *  How it works:
 *  
 *      If bit is 0:    0 ^ 1 = 1  (becomes 1)
 *      If bit is 1:    1 ^ 1 = 0  (becomes 0)
 *  
 *  Example:
 *      Register:       0 1 1 0 1 0 0 0
 *      Mask (1<<5):    0 0 1 0 0 0 0 0
 *                    ^ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      Result:         0 1 0 0 1 0 0 0
 *                          â†‘
 *                    Bit 5 TOGGLED!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

void example_toggle_bit(void) {
    /* Toggle bit 5 */
    example_register ^= (1 << 5);
    
    /* Toggle LED (common pattern) */
    /* GPIOB->ODR ^= (1 << 0); */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OPERATION 4: CHECK A BIT (read its value)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  Pattern: if (register & (1 << bit_number))
 *  
 *  How it works:
 *  
 *      Register:       0 1 1 0 1 0 0 0
 *      Mask (1<<5):    0 0 1 0 0 0 0 0
 *                    & â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      Result:         0 0 1 0 0 0 0 0  â† Non-zero = bit is SET
 *  
 *      Register:       0 1 0 0 1 0 0 0
 *      Mask (1<<5):    0 0 1 0 0 0 0 0
 *                    & â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *      Result:         0 0 0 0 0 0 0 0  â† Zero = bit is CLEAR
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

uint8_t example_check_bit(void) {
    /* Check if bit 5 is set */
    if (example_register & (1 << 5)) {
        return 1;   /* Bit is SET */
    } else {
        return 0;   /* Bit is CLEAR */
    }
    
    /* Shorter version: */
    /* return (example_register & (1 << 5)) ? 1 : 0; */
    
    /* Or even shorter (returns non-zero if set): */
    /* return (example_register & (1 << 5)); */
}

/* ============================================================================
 * 
 *  LESSON 3: BIT FIELDS (Multiple Bits Per Setting)
 *  =================================================
 * 
 *  Many registers use MULTIPLE BITS for a single setting.
 *  
 *  Example: GPIO MODER register uses 2 BITS per pin.
 *  
 *  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *  â”‚ MODER Register (32 bits for 16 pins)                                   â”‚
 *  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ Pin 15 â”‚ Pin 14 â”‚ Pin 13 â”‚ Pin 12 â”‚ ... â”‚ Pin 2  â”‚ Pin 1  â”‚   Pin 0    â”‚
 *  â”‚ [31:30]â”‚ [29:28]â”‚ [27:26]â”‚ [25:24]â”‚     â”‚ [5:4]  â”‚ [3:2]  â”‚   [1:0]    â”‚
 *  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  Each 2-bit field can have 4 values:
 *  00 = Input
 *  01 = Output
 *  10 = Alternate Function
 *  11 = Analog
 * 
 * ============================================================================ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  THE FORMULA: bit_position = pin_number Ã— bits_per_setting
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  For MODER (2 bits per pin):
 *  
 *      Pin 0:  bit_position = 0 Ã— 2 = 0   (bits 1:0)
 *      Pin 1:  bit_position = 1 Ã— 2 = 2   (bits 3:2)
 *      Pin 2:  bit_position = 2 Ã— 2 = 4   (bits 5:4)
 *      Pin 5:  bit_position = 5 Ã— 2 = 10  (bits 11:10)
 *      Pin 13: bit_position = 13 Ã— 2 = 26 (bits 27:26)
 *  
 *  Visual for Pin 5 (bits 11:10):
 *  
 *      Bit:    31 30 29 28 ... 11 10 9 8 ... 1 0
 *                             â””â”€â”€â”¬â”€â”€â”˜
 *                             Pin 5 field
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  CREATING MULTI-BIT MASKS
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  For a 2-bit field: mask = 0b11 = 0x3 = 3
 *  For a 4-bit field: mask = 0b1111 = 0xF = 15
 *  
 *  To position the mask:
 *      mask_at_position = base_mask << (pin Ã— bits_per_setting)
 *  
 *  Example for Pin 5 with 2-bit field:
 *      base_mask = 0x3 (binary: 11)
 *      position = 5 Ã— 2 = 10
 *      mask = 0x3 << 10 = 0x00000C00
 *  
 *      In binary:
 *      0x00000C00 = 0000 0000 0000 0000 0000 1100 0000 0000
 *                                           â””â”€â”¬â”€â”˜
 *                                          bits 11:10
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Example: Fake GPIO registers for practice */
volatile uint32_t FAKE_MODER = 0;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   WHY "volatile"?
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  
 *  The `volatile` keyword tells the compiler: "This value can change at any
 *  time, even if my code didn't change it."
 *  
 *  WITHOUT volatile:
 *      Compiler sees: "I just read this register, so the value is cached."
 *      Compiler optimizes out the next read: "Why read it again? I know the value!"
 *      Result: Your code BREAKS - it misses hardware changes!
 *  
 *  WITH volatile:
 *      Compiler always reads from the actual hardware register.
 *      No optimization, no caching, no "shortcuts".
 *  
 *  WHEN TO USE:
 *  - ALL hardware registers (GPIO, UART, ADC, etc.)
 *  - Variables modified by interrupts
 *  - Memory-mapped peripherals
 *  
 *  Example without volatile (BROKEN):
 *      uint32_t status = USART->ISR;    // Read once
 *      while (!(status & FLAG));         // Compiler uses cached value - STUCK FOREVER!
 *  
 *  Example with volatile (CORRECT):
 *      volatile uint32_t *isr = &USART->ISR;
 *      while (!(*isr & FLAG));           // Compiler re-reads every time - works!
 *  
 *  REMEMBER: Hardware registers can change independently of your code.
 *            The volatile keyword prevents the compiler from "optimizing away"
 *            essential reads and writes!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 1: SET A SINGLE BIT
 *  ==================================
 * 
 *  Set bit 7 in the register.
 * 
 * ============================================================================ */

void Exercise1_SetBit7(void) {
    /* âœï¸ YOUR TURN: Set bit 7 */
    example_register |= ???;    /* HINT: Left-shift 1 to the bit position you want to set */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * void Exercise1_SetBit7(void) {
 *     example_register |= (1 << 7);
 * }
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 2: CLEAR A SINGLE BIT
 *  ====================================
 * 
 *  Clear bit 3 in the register.
 * 
 * ============================================================================ */

void Exercise2_ClearBit3(void) {
    /* âœï¸ YOUR TURN: Clear bit 3 */
    example_register &= ???;    /* HINT: AND with inverted mask. Create mask then invert with ~ */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * void Exercise2_ClearBit3(void) {
 *     example_register &= ~(1 << 3);
 * }
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 3: CONFIGURE A 2-BIT FIELD
 *  =========================================
 * 
 *  Set Pin 5 to OUTPUT mode (01) in MODER register.
 *  Remember: 2 bits per pin, so position = 5 Ã— 2 = 10
 *  
 *  Step 1: Clear the 2-bit field first
 *  Step 2: Set the new value
 * 
 * ============================================================================ */

void Exercise3_SetPin5Output(void) {
    /* âœï¸ YOUR TURN: Clear bits 11:10 (the 2-bit field for pin 5) */
    FAKE_MODER &= ???;          /* HINT: Invert a 2-bit mask (0x3) shifted to pin 5's position */
    
    /* âœï¸ YOUR TURN: Set value 01 (output) at bits 11:10 */
    FAKE_MODER |= ???;          /* HINT: Shift value 1 (output mode) to pin 5's position. Remember: 2 bits per pin! */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * void Exercise3_SetPin5Output(void) {
 *     FAKE_MODER &= ~(3U << (5 * 2));  // Clear bits 11:10
 *     FAKE_MODER |= (1U << (5 * 2));   // Set to 01 (output)
 * }
 * 
 * EXPLANATION:
 * 
 *   Step 1: Clear the field
 *   
 *       3U = 0b11 (the mask for 2 bits)
 *       3U << 10 = 0b110000000000 (mask at position 10)
 *       ~(3U << 10) = 0b...11111111111001111111111 (inverted)
 *       FAKE_MODER &= ~(3U << 10) â†’ clears bits 11:10, keeps others
 *   
 *   Step 2: Set the value
 *   
 *       1U = 0b01 (the value we want: output mode)
 *       1U << 10 = 0b010000000000 (value at position 10)
 *       FAKE_MODER |= (1U << 10) â†’ sets bit 10, bit 11 stays 0
 *   
 *   Result: bits 11:10 = 01 = Output mode!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 4: CONFIGURE A 4-BIT FIELD
 *  =========================================
 * 
 *  The AFR (Alternate Function Register) uses 4 bits per pin.
 *  Set Pin 3 to AF7 (for UART) in AFR[0].
 *  
 *  4 bits per pin, so position = 3 Ã— 4 = 12
 *  AF7 = 0b0111 = 7
 * 
 * ============================================================================ */

volatile uint32_t FAKE_AFR = 0;

void Exercise4_SetPin3_AF7(void) {
    /* âœï¸ YOUR TURN: Clear the 4-bit field for pin 3 (bits 15:12) */
    FAKE_AFR &= ???;            /* HINT: Invert a 4-bit mask (0xF) shifted to pin 3's position. 4 bits per pin! */
    
    /* âœï¸ YOUR TURN: Set AF7 at bits 15:12 */
    FAKE_AFR |= ???;            /* HINT: Shift the AF value (7) to pin 3's bit position */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * void Exercise4_SetPin3_AF7(void) {
 *     FAKE_AFR &= ~(0xFU << (3 * 4));  // Clear bits 15:12
 *     FAKE_AFR |= (7U << (3 * 4));     // Set to 7 (AF7)
 * }
 * 
 * EXPLANATION:
 * 
 *   0xF = 0b1111 (mask for 4 bits)
 *   0xF << 12 = 0xF000 (mask at bits 15:12)
 *   7 = 0b0111 (AF7 value)
 *   7 << 12 = 0x7000 (value at bits 15:12)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 5: CHECK IF A BIT IS SET
 *  ======================================
 * 
 *  Return 1 if bit 4 is set, 0 otherwise.
 * 
 * ============================================================================ */

uint8_t Exercise5_IsBit4Set(void) {
    /* âœï¸ YOUR TURN: Check bit 4 and return result */
    if (example_register & ???) {   /* HINT: Create a mask that isolates only bit 4 */
        return 1;
    }
    return 0;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * uint8_t Exercise5_IsBit4Set(void) {
 *     if (example_register & (1 << 4)) {
 *         return 1;
 *     }
 *     return 0;
 * }
 * 
 * // Or shorter:
 * uint8_t Exercise5_IsBit4Set(void) {
 *     return (example_register & (1 << 4)) ? 1 : 0;
 * }
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 6: READ A 2-BIT FIELD VALUE
 *  ==========================================
 * 
 *  Read the mode of Pin 5 from MODER (bits 11:10).
 *  Return the 2-bit value (0, 1, 2, or 3).
 * 
 * ============================================================================ */

uint8_t Exercise6_ReadPin5Mode(void) {
    /* âœï¸ YOUR TURN: Mask and shift to get the 2-bit value */
    return (FAKE_MODER >> ???) & ???;   /* HINT: Shift right to bring bits to position 0, then mask with 0x3 for 2 bits */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * uint8_t Exercise6_ReadPin5Mode(void) {
 *     return (FAKE_MODER >> (5 * 2)) & 0x3;
 * }
 * 
 * EXPLANATION:
 * 
 *   1. Shift right by (5 * 2) = 10 bits
 *      This moves bits 11:10 down to bits 1:0
 *   
 *   2. Mask with 0x3 (0b11)
 *      This keeps only the bottom 2 bits
 *   
 *   Example:
 *   FAKE_MODER = 0x00000C00 (bits 11:10 = 11)
 *   >> 10      = 0x00000003 (now bits 1:0 = 11)
 *   & 0x3      = 0x00000003 = 3
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  âœï¸  EXERCISE 7: COMBINE MULTIPLE SETTINGS
 *  ===========================================
 * 
 *  Configure a SPI register with multiple bit fields:
 *  - Set bits 5:3 to value 4 (data size)
 *  - Set bits 10:8 to value 5 (prescaler)
 *  
 *  Do it all in one line!
 * 
 * ============================================================================ */

volatile uint32_t FAKE_SPI_CFG = 0;

void Exercise7_CombineSettings(void) {
    /* âœï¸ YOUR TURN: Set both fields in one statement */
    FAKE_SPI_CFG = ???;         /* HINT: OR together both values, each shifted to their bit positions */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ğŸ’¡ SOLUTION:
 * 
 * void Exercise7_CombineSettings(void) {
 *     FAKE_SPI_CFG = (4U << 3) | (5U << 8);
 * }
 * 
 * EXPLANATION:
 * 
 *   (4U << 3)  = 0b00000000000000000000000000100000 = value 4 at bits 5:3
 *   (5U << 8)  = 0b00000000000000000000010100000000 = value 5 at bits 10:8
 *   
 *   OR them together:
 *              = 0b00000000000000000000010100100000
 *   
 *   This is a common pattern! You'll see it everywhere in peripheral config.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ============================================================================
 * 
 *  LESSON 4: THE U SUFFIX AND TYPE SAFETY
 *  =======================================
 * 
 *  You'll see "U" after numbers: (1U << 31)
 *  
 *  Why?
 *  - Without U: The number 1 is signed int (can be negative)
 *  - With U: The number 1U is unsigned int (always positive)
 *  
 *  Problem case:
 *      (1 << 31) might give wrong result (signed overflow!)
 *      (1U << 31) is correct (0x80000000)
 *  
 *  RULE: Always use U suffix when doing bit shifts!
 *  
 *      âŒ (1 << 31)   - May cause issues
 *      âœ… (1U << 31)  - Always correct
 * 
 * ============================================================================ */

/* ============================================================================
 * 
 *  LESSON 5: COMMON PATTERNS IN STM32 PROGRAMMING
 *  ================================================
 * 
 *  Here's a cheat sheet of patterns you'll use constantly!
 * 
 * ============================================================================ */

/* Define for a fake GPIO port */
#define FAKE_GPIOB_BASE 0x58020400UL

typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
    volatile uint32_t BSRR;
    volatile uint32_t LCKR;
    volatile uint32_t AFR[2];
} FakeGPIO_TypeDef;

#define FAKE_GPIOB ((FakeGPIO_TypeDef *) FAKE_GPIOB_BASE)

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 1: Enable a clock
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    RCC->AHB4ENR |= (1U << 1);  // Enable GPIOB clock (bit 1)
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 2: Configure GPIO as output (2-bit field)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    #define PIN 5
    
    GPIOB->MODER &= ~(3U << (PIN * 2));  // Clear bits (set to input)
    GPIOB->MODER |= (1U << (PIN * 2));   // Set to output (01)
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 3: Set output HIGH
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    GPIOB->ODR |= (1U << PIN);    // Using ODR
    GPIOB->BSRR = (1U << PIN);    // Using BSRR 
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 4: Set output LOW
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    GPIOB->ODR &= ~(1U << PIN);       // Using ODR
    GPIOB->BSRR = (1U << (PIN + 16)); // Using BSRR 
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 5: Toggle output
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    GPIOB->ODR ^= (1U << PIN);
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 6: Check if input is HIGH
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    if (GPIOB->IDR & (1U << PIN)) {
        // Pin is HIGH
    }
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 7: Wait for a flag to be set
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    while (!(USART->ISR & (1U << 7)));  // Wait until bit 7 is set
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 8: Wait for a flag to be cleared
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    while (USART->ISR & (1U << 7));     // Wait until bit 7 is clear
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 9: Set alternate function (4-bit field)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    // For pins 0-7, use AFR[0]
    GPIOB->AFR[0] &= ~(0xFU << (PIN * 4));  // Clear 4 bits
    GPIOB->AFR[0] |= (7U << (PIN * 4));     // Set to AF7
    
    // For pins 8-15, use AFR[1] and subtract 8
    GPIOB->AFR[1] &= ~(0xFU << ((PIN - 8) * 4));
    GPIOB->AFR[1] |= (4U << ((PIN - 8) * 4));
*/

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  PATTERN 10: Use predefined bit masks (cleaner code)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
    #define USART_ISR_TXE   (1U << 7)
    #define USART_ISR_RXNE  (1U << 5)
    #define USART_CR1_TE    (1U << 3)
    #define USART_CR1_RE    (1U << 2)
    
    USART->CR1 |= USART_CR1_TE | USART_CR1_RE;  // Enable TX and RX
    while (!(USART->ISR & USART_ISR_TXE));       // Wait for TX empty
*/

/* ============================================================================
 * 
 *  LESSON 6: QUICK REFERENCE TABLE
 *  ================================
 *  
 *  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *  â”‚ Operation        â”‚ Code Pattern                 â”‚ Example                â”‚
 *  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ Set bit n        â”‚ reg |= (1U << n);            â”‚ reg |= (1U << 5);      â”‚
 *  â”‚ Clear bit n      â”‚ reg &= ~(1U << n);           â”‚ reg &= ~(1U << 5);     â”‚
 *  â”‚ Toggle bit n     â”‚ reg ^= (1U << n);            â”‚ reg ^= (1U << 5);      â”‚
 *  â”‚ Check bit n      â”‚ if (reg & (1U << n))         â”‚ if (reg & (1U << 5))   â”‚
 *  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ Clear 2-bit fieldâ”‚ reg &= ~(3U << (p*2));       â”‚ reg &= ~(3U << 10);    â”‚
 *  â”‚ Set 2-bit value  â”‚ reg |= (val << (p*2));       â”‚ reg |= (1U << 10);     â”‚
 *  â”‚ Clear 4-bit fieldâ”‚ reg &= ~(0xFU << (p*4));     â”‚ reg &= ~(0xFU << 12);  â”‚
 *  â”‚ Set 4-bit value  â”‚ reg |= (val << (p*4));       â”‚ reg |= (7U << 12);     â”‚
 *  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *  â”‚ Read 2-bit field â”‚ (reg >> (p*2)) & 0x3         â”‚ (reg >> 10) & 0x3      â”‚
 *  â”‚ Read 4-bit field â”‚ (reg >> (p*4)) & 0xF         â”‚ (reg >> 12) & 0xF      â”‚
 *  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *  
 *  Remember: p = pin number, val = value to set
 * 
 * ============================================================================ */

/* ============================================================================
 * 
 *  ğŸ‰ CONGRATULATIONS!
 *  
 *  You now understand bit manipulation - the foundation of ALL embedded
 *  programming!
 *  
 *  âœ… Binary and hexadecimal number systems
 *  âœ… All 6 bitwise operators: & | ^ ~ << >>
 *  âœ… Setting, clearing, toggling, and checking bits
 *  âœ… Multi-bit fields (2-bit, 4-bit)
 *  âœ… The (pin Ã— bits_per_setting) formula
 *  âœ… Common STM32 programming patterns
 *  
 *  YOU'RE READY FOR THE GPIO TUTORIAL!
 *  
 *  Quick summary:
 *  â€¢ SET bit:    |=  (1U << n)
 *  â€¢ CLEAR bit:  &= ~(1U << n)
 *  â€¢ TOGGLE bit: ^=  (1U << n)
 *  â€¢ CHECK bit:  &   (1U << n)
 *  
 *  For multi-bit fields:
 *  â€¢ Position = pin Ã— bits_per_setting
 *  â€¢ Clear first, then set!
 * 
 * ============================================================================ */

int main(void)
{
    /* Test your understanding! */
    
    example_register = 0;
    
    /* Set bits 0, 3, and 7 */
    example_register |= (1U << 0) | (1U << 3) | (1U << 7);
    /* Result: 0b10001001 = 0x89 = 137 */
    
    /* Clear bit 3 */
    example_register &= ~(1U << 3);
    /* Result: 0b10000001 = 0x81 = 129 */
    
    /* Toggle bit 4 */
    example_register ^= (1U << 4);
    /* Result: 0b10010001 = 0x91 = 145 */
    
    /* Check if bit 7 is set */
    if (example_register & (1U << 7)) {
        /* Yes, bit 7 is set! */
    }
    
    for(;;) {
        /* Your practice code here */
    }
}
